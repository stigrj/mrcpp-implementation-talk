name: inverse
layout: true
class: center, middle, inverse
---
#MRCPP
##Implementation

.author[Stig Rune Jensen]

.date[3 August 2016, Stony Brook, NY]

.footnote[Slides available on [GitHub](https://github.com/stigrj/mrcpp-implementation-talk)]

---

layout: false
.left-column[
## Technical stuff
]
.right-column[
- Hosted on GitHub

- Documentation on ReadTheDocs

- Configuration with (Auto)cmake

- Testing with Catch

- Number crunching with BLAS

- Parallelization with OpenMP
]

---
template: inverse
# Data structures
---

.left-column[
## Data structures
### - MWTree
]
.right-column[
- Functions and operators organized in tree structures

- Memory allocator keeps data localized

- MRA defines
  * Root scale (can be negative)
  * Number of root nodes
  * Type of MW basis (Legendre/Interpolating)
  * Order of MW basis (`\(1 \leq k \leq 40\)`)

```cpp
template<int D>
class MWTree {
    TreeAllocator<D> allocator;         // Memory allocator
    MultiResolutionAnalysis<D> MRA;     // World, MW basis

    std::vector<MWNode<D> *> rootNodes; // Root container
    std::vector<MWNode<D> *> leafNodes; // Leaf container

    double squareNorm;                  // Squared L^2 norm
    std::vector<int> nodesAtDepth;      // Node counter
}
```
]

---

.left-column[
## Data structures
### - MWTree
### - MWNode
]
.right-column[
- NodeIndex defines
  * length scale (`\(2^{-n}\)`)
  * translation (`\([l/2^{n},(l+1)/2^{n}]\)`)

- Each node keeps __both__ scaling and wavelet coefficients

```cpp
template<int D>
class MWNode {
    NodeIndex<D> idx;           // Scale and translation

    MWTree<D> *tree;            // Tree it belongs to
    MWNode<D> *parent;          // Parent node
    MWNode<D> *children[2^D];   // Children nodes

    double squareNorm;          // Squared L^2 norm
    double componentNorms[2^D]; // Scaling/wavelet norms
    double *coefs;              // Scaling/wavelet coefs
}
```
]

---

.left-column[
## Data structures
### - MWTree
### - MWNode
]
.right-column[
#### Representations

- MRA allows for fine-scale representation

  `$$ f^N = \sum_{l=0}^{2^N-1}\sum_{j=0}^{k} s_{jl}^N \phi_{jl}^N(x) $$`

- or multi-scale representation

  `$$ f^N = \sum_{j=0}^{k} s_{jl}^0 \phi_{jl}^0(x) +
  \sum_{n=0}^{N-1}\sum_{l=0}^{2^N-1}\sum_{j=0}^{k} w_{jl}^n \psi_{jl}^n(x) $$`

- We keep a __redundant__ representation of both scaling and wavelet
  coefficients on __all__ scales
]

---

.left-column[
## Data structures
### - MWTree
### - MWNode
]
.right-column[
#### Transformations

- We can go from a `\(V^n \oplus W^n\)` representation
  to a `\(V^{n+1}\)` representation using the MW transform

- We can go from a `\(V^{n+1}\)` representation to a function value
  representation using the CV transform (coefficient-value)

```cpp
MWNode<D> node;                     // V^{n} + W^{n}

node.mwTransform(Reconstruction);   // V^{n+1}
    
node.cvTransform(Forward);          // Function values
    
node.cvTransform(Backward);         // V^{n+1}
    
node.mwTransform(Compression);      // V^{n} + W^{n}
```
]

---

.left-column[
## Data structures
### - MWTree
### - MWNode
]
.right-column[
#### Transformations

- Often require nodes beyond the finest refinement level

- Information available by MW transform

- Corresponds to an oversampling of the function

- Possible strategies
  * perform MW transforms on the fly whenever needed
  * extend the tree with temporary nodes for later use

- GenNodes
  * generated by MW transform
  * only scaling coefs (wavelet coefs are zero)
  * kept until the particular operation is completed
]

---

layout: false
.left-column[
## Data structures
### - MWNode
### - MWTree
### - MWOperator
]
.right-column[
#### Convolution operators
- General nD integral operator

  `$$ 
    \hat{T}f(\boldsymbol{x}) = 
    \int K(\boldsymbol{x},\boldsymbol{y})f(\boldsymbol{y}) d\boldsymbol{y}
   $$`

- Separable representation

  `$$
    K(\boldsymbol{x},\boldsymbol{y}) \approx 
    \tilde{K}(\boldsymbol{x},\boldsymbol{y}) =
    \sum_\kappa^M \alpha_\kappa \prod_{p=0}^d K_p^d(x_p,y_p)
   $$`

- Find parameters such that

  `$$
    sup_y\left|\frac{K(\boldsymbol{x},\boldsymbol{y}) -
    \tilde{K}(\boldsymbol{x},\boldsymbol{y})}
    {K(\boldsymbol{x},\boldsymbol{y})}\right| \leq
    \epsilon
   $$`

- Decompose into a sum of products of 1D operators

- Reduce the complexity from `\(k^{2d}\)` to `\(Mdk^{d+1}\)`
]

---

layout: false
.left-column[
## Data structures
### - MWNode
### - MWTree
### - MWOperator
]
.right-column[
#### Poisson operator
- The Poisson equation relates the electrostatic potential `\(V\)`
  to the charge density `\(\rho\)`
 
  `$$
    \nabla^2 V(\boldsymbol{x}) = -\rho(\boldsymbol{x})
   $$`

- Direct solution in integral form
  `$$
    V(\boldsymbol{x}) =
    \int P(\boldsymbol{x},\boldsymbol{y})\rho(\boldsymbol{y}) d\boldsymbol{y}
   $$`

]


---

layout: false
.left-column[
## Data structures
### - MWNode
### - MWTree
### - MWOperator
]
.right-column[
#### Convolution operators

]


---

layout: false
.left-column[
## Data structures
### - MWNode
### - MWTree
### - MWOperator
]
.right-column[
#### Convolution operators

]

---

layout: false
.left-column[
## Data structures
### - MWNode
### - MWTree
### - MWOperator
]
.right-column[
#### Convolution operators

- MW operators are 2D trees
- Construction CCC etc
- Decomposition
  * Gaussian expansion
  * Length scales
  * Wavelets: A, B, C and T 
- Linear scaling
  * Vanishing moments
  * Bandwidths
]

---
template: inverse
# Algorithms
---

layout: false
.left-column[
## Algorithms
### - Adaptivity
### - Thresholding
]
.right-column[
- Tree building algorithm
- Function thresholding
- MW transforms
]

---

layout: false
.left-column[
## Algorithms
### - Projection
### - Addition
### - Multiplication
### - Operator application
]
.right-column[
- Interpolating property
- cvTransform
- mwTransform
- NS form
- Bandwidths
- Pointer array
- Operator thresholding
- GenNodes
]

---
template: inverse
# Parallelization
---

layout: false
.left-column[
## Parallelization
]
.right-column[
- Tree building algorithm
]

---

## Acknowldegements

- Luca Frediani

- Tor Fl√•

- Radovan Bast

- Jonas Juselius

---
name: last-page
template: inverse

Slideshow created using [remark] and served using [cicero]

[remark]: https://github.com/gnab/remark
[cicero]: https://github.com/bast/cicero
