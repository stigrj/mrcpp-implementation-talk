name: inverse
layout: true
class: center, middle, inverse
---
#MRCPP
##Implementation

.author[Stig Rune Jensen]

.date[3 August 2016, Stony Brook, NY]

.footnote[Slides available on [GitHub](https://github.com/stigrj/mrcpp-implementation-talk)]

---

layout: false
.left-column[
## Technical stuff
]
.right-column[
- Hosted on GitHub

- Documentation on ReadTheDocs

- Configuration with (Auto)cmake

- Testing with Catch

- Number crunching with BLAS

- Parallelization with OpenMP
]

---
template: inverse
# Data structures
---

.left-column[
## Data structures
### - MWTree
]
.right-column[
- Functions and operators organized in D-dimensional tree structures

- Memory allocator keeps data localized

- MRA defines
  * Root scale (can be negative)
  * Number of root nodes
  * Type of MW basis (Legendre/Interpolating)
  * Order of MW basis (`\(1 \leq k \leq 40\)`)

```cpp
template<int D>
class MWTree {
    TreeAllocator<D> allocator;         // Memory allocator
    MultiResolutionAnalysis<D> MRA;     // World, MW basis

    std::vector<MWNode<D> *> rootNodes; // Root container
    std::vector<MWNode<D> *> leafNodes; // Leaf container

    double squareNorm;                  // Squared L^2 norm
    std::vector<int> nodesAtDepth;      // Node counter
}
```
]

---

.left-column[
## Data structures
### - MWTree
### - MWNode
]
.right-column[
- NodeIndex defines
  * length scale (:math:`2^{-n}`)
  * translation (:math:`[l/2^{n},(l+1)/2^{n}]`)
- Each node keeps __both__ scaling and wavelet coefficients

```cpp
template<int D>
class MWNode {
    NodeIndex<D> idx;           // Scale and translation

    MWTree<D> *tree;            // Tree it belongs to
    MWNode<D> *parent;          // Parent node
    MWNode<D> *children[2^D];   // Children nodes

    double squareNorm;          // Squared L^2 norm
    double componentNorms[2^D]; // Scaling/wavelet norms
    double *coefs;              // Scaling/wavelet coefs
}
```
]

---

.left-column[
## Data structures
### - MWTree
### - MWNode
]
.right-column[
- MRA allows for either fine-scale representation in scaling functions

  `$$ f^N = \sum_{l=0}^{2^N-1}\sum_{j=0}^{k} s_{jl}^N \phi_{jl}^N(x) $$`

- or multi-scale representation in wavelet functions

  `$$ f^N = \sum_{j=0}^{k} s_{jl}^0 \phi_{jl}^0(x) +
  \sum_{n=0}^{N}\sum_{l=0}^{2^N-1}\sum_{j=0}^{k} w_{jl}^n \psi_{jl}^n(x) $$`

- We keep a __redundant__ representation of both scaling and wavelet on
  __all__ scales
]

---

.left-column[
## Data structures
### - MWTree
### - MWNode
]
.right-column[
- We can go from a `\(V^n \oplus W^n\)` representation
  to a `\(V^{n+1}\)` representation using the MW transform

- We can go from a `\(V^{n+1}\)` representation to a function value
  representation using the CV (coefficient-value) transform

```cpp
    MWNode<D> node;                     // V^n + W^n
    node.mwTransform(Reconstruction);   // V^{n+1}
    node.cvTransform(Forward);          // function values
    node.cvTransform(Backward);         // V^{n+1})
    node.mwTransform(Compression);      // V^n + W^n
```
]

---

.left-column[
## Data structures
### - MWTree
### - MWNode
]
.right-column[
- Often require nodes beyond the finest refinement level

- Information available by MW transform

- Corresponds to oversampling of the function

- Possible strategies
  * perform MW transforms on the fly whenever needed
  * extend the tree with temporary nodes for later use

- GenNodes
  * generated by MW transform
  * only scaling coefs (wavelet coefs are zero)
  * kept until the particular operation is completed

]

---

layout: false
.left-column[
## Data structures
### - MWNode
### - MWTree
### - MWOperator
]
.right-column[
- Construction CCC etc
- Decomposition
  * Gaussian expansion
  * Length scales
  * Wavelets: A, B, C and T 
- Linear scaling
  * Vanishing moments
  * Bandwidths
]

---
template: inverse
# Algorithms
---

layout: false
.left-column[
## Algorithms
### - Adaptivity
### - Thresholding
]
.right-column[
- Tree building algorithm
- Function thresholding
- MW transforms
]

---

layout: false
.left-column[
## Algorithms
### - Projection
### - Addition
### - Multiplication
### - Operator application
]
.right-column[
- Interpolating property
- cvTransform
- mwTransform
- NS form
- Bandwidths
- Pointer array
- Operator thresholding
- GenNodes
]

---
template: inverse
# Parallelization
---

layout: false
.left-column[
## Parallelization
]
.right-column[
- Tree building algorithm
]

---

## Acknowldegements

- Luca Frediani

- Tor Fl√•

- Radovan Bast

- Jonas Juselius

---
name: last-page
template: inverse

Slideshow created using [remark] and served using [cicero]

[remark]: https://github.com/gnab/remark
[cicero]: https://github.com/bast/cicero
