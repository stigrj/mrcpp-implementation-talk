name: inverse
layout: true
class: center, middle, inverse
---
#MRCPP
##Implementation

.author[Stig Rune Jensen]

.date[3 August 2016, Stony Brook, NY]

.footnote[Slides available on [GitHub](https://github.com/stigrj/mrcpp-implementation-talk)]

---

layout: false
.left-column[
## Technical stuff
]
.right-column[
- Hosted on GitHub

- Documentation on ReadTheDocs

- Configuration with (Auto)cmake

- Testing with Catch

- Number crunching with BLAS

- Parallelization with OpenMP
]

---
template: inverse
# Data structures
---

.left-column[
## Data structures
### - MWTree
]
.right-column[
- Functions and operators organized in tree structures

- Memory allocator keeps data localized

- MRA defines
  * Root scale (can be negative)
  * Number of root nodes
  * Type of MW basis (Legendre/Interpolating)
  * Order of MW basis (`\(1 \leq k \leq 40\)`)

```cpp
template<int D>
class MWTree {
    TreeAllocator<D> allocator;      // Memory allocator
    MultiResolutionAnalysis<D> MRA;  // World, MW basis

    std::vector<MWNode<D> *> roots;  // Root container
    std::vector<MWNode<D> *> leaves; // Leaf container

    double squareNorm;               // Squared L^2 norm
    std::vector<int> nodesAtDepth;   // Node counter
}
```
]

---

.left-column[
## Data structures
### - MWTree
### - MWNode
]
.right-column[
- NodeIndex defines
  * Length scale: `\(2^{-n}\)`
  * Translation: `\([l/2^{n},(l+1)/2^{n}]\)`

- Each node keeps __both__ scaling and wavelet coefficients

```cpp
template<int D>
class MWNode {
    NodeIndex<D> idx;           // Scale and translation

    MWTree<D> *tree;            // Tree it belongs to
    MWNode<D> *parent;          // Parent node
    MWNode<D> *children[2^D];   // Children nodes

    double squareNorm;          // Squared L^2 norm
    double componentNorms[2^D]; // Scaling/wavelet norms
    double *coefs;              // Scaling/wavelet coefs
}
```
]

---

.left-column[
## Data structures
### - MWTree
### - MWNode
]
.right-column[
<img src="images/adaptivity.jpg" style="width: 80%; float: center">
]

---

.left-column[
## Data structures
### - MWTree
### - MWNode
]
.right-column[
#### Representations

- MRA allows for fine-scale representation

  `$$ f^N = \sum_{l=0}^{2^N-1}\sum_{j=0}^{k} s_{jl}^N \phi_{jl}^N(x) $$`

- or multi-scale representation

  `$$ f^N = \sum_{j=0}^{k} s_{jl}^0 \phi_{jl}^0(x) +
  \sum_{n=0}^{N-1}\sum_{l=0}^{2^N-1}\sum_{j=0}^{k} w_{jl}^n \psi_{jl}^n(x) $$`

- We keep a __redundant__ representation of both scaling and wavelet
  coefficients on __all__ scales
]

---

.left-column[
## Data structures
### - MWTree
### - MWNode
]
.right-column[
#### Transformations

- We can go from a `\(V^n \oplus W^n\)` representation
  to a `\(V^{n+1}\)` representation using the MW transform

- We can go from a `\(V^{n+1}\)` representation to a function value
  representation using the CV transform (coefficient-value)

```cpp
MWNode<D> node;                     // V^{n} + W^{n}

node.mwTransform(Reconstruction);   // V^{n+1}
    
node.cvTransform(Forward);          // Function values
    
node.cvTransform(Backward);         // V^{n+1}
    
node.mwTransform(Compression);      // V^{n} + W^{n}
```
]

---

.left-column[
## Data structures
### - MWTree
### - MWNode
]
.right-column[
#### Transformations

- Often require nodes beyond the finest refinement level

- Information available by MW transform

- Corresponds to an oversampling of the function

- Possible strategies
  * perform MW transforms on the fly whenever needed
  * extend the tree with temporary nodes for later use

- GenNodes
  * generated by MW transform
  * only scaling coefs (wavelet coefs are zero)
  * kept until the particular operation is completed
]

---

layout: false
.left-column[
## Data structures
### - MWTree
### - MWNode
### - MWOperator
]
.right-column[
#### Convolution operators
- General nD integral operator

  `$$ 
    \hat{T}f(\boldsymbol{x}) = 
    \int K(\boldsymbol{x},\boldsymbol{y})f(\boldsymbol{y}) d\boldsymbol{y}
   $$`

- Separable representation

  `$$
    K(\boldsymbol{x},\boldsymbol{y}) \approx 
    \tilde{K}(\boldsymbol{x},\boldsymbol{y}) =
    \sum_\kappa^M \alpha_\kappa \prod_{p=1}^d K_p^\kappa(x_p,y_p)
   $$`

- Find parameters such that

  `$$
    sup_y\left|\frac{K(\boldsymbol{x},\boldsymbol{y}) -
    \tilde{K}(\boldsymbol{x},\boldsymbol{y})}
    {K(\boldsymbol{x},\boldsymbol{y})}\right| \leq
    \epsilon
   $$`

- Decompose into a sum of products of 1D operators

- Reduce the complexity from `\(k^{2d}\)` to `\(Mdk^{d+1}\)`
]

---

layout: false
.left-column[
## Data structures
### - MWTree
### - MWNode
### - MWOperator
]
.right-column[
#### Poisson operator
- The Poisson equation relates the electrostatic potential `\(V\)`
  to the charge density `\(\rho\)`
 
  `$$
    \nabla^2 V(\boldsymbol{x}) = -\rho(\boldsymbol{x})
   $$`

- Direct solution in integral form
  `$$
    V(\boldsymbol{x}) =
    \int P(\boldsymbol{x},\boldsymbol{y})\rho(\boldsymbol{y}) d\boldsymbol{y}
   $$`

- Poisson kernel

  `$$
    P(\boldsymbol{x},\boldsymbol{y}) = \frac{1}{4\pi\|\boldsymbol{x}-\boldsymbol{y}\|}
   $$`

- Numerical problems
  * Non-separable
  * Singularity at short range
  * Slow decay at long range
]

---

layout: false
.left-column[
## Data structures
### - MWTree
### - MWNode
### - MWOperator
]
.right-column[
#### Poisson operator
- Poisson kernel separated in terms of Gaussians
  `$$
    P(\boldsymbol{x},\boldsymbol{y}) \approx
    \tilde{P}(\boldsymbol{x},\boldsymbol{y}) =
    \sum_\kappa^M \alpha_{\kappa} \prod_{p=1}^d e^{-\beta_{\kappa}(x_p-y_p)^2}
   $$`

- Expansion obtained from the relation

  `$$
    \frac{1}{r} = \frac{4}{\sqrt{\pi}}\int_0^\infty e^{-4r^2t^2} dt
   $$`

- Substitution: `\(t = log(1+e^u)-u\)`
  
  `$$
    \frac{1}{r} = \int_{-\infty}^{\infty} f_1(u) du
   $$`

- Substitution: `\(u = -sinh(w)\)`
  
  `$$
    \frac{1}{r} = \int_{-\infty}^{\infty} f_2(w) dw
   $$`

- Super-exponential decay for `\(w \rightarrow \pm \infty\)` 
]

---

layout: false
.left-column[
## Data structures
### - MWTree
### - MWNode
### - MWOperator
]
.right-column[
#### Poisson operator
- Poisson kernel separated in terms of Gaussians

  `$$
    P(\boldsymbol{x},\boldsymbol{y}) \approx
    \tilde{P}(\boldsymbol{x},\boldsymbol{y}) =
    \sum_\kappa^M \alpha_{\kappa} \prod_{p=1}^d e^{-\beta_{\kappa}(x_p-y_p)^2}
   $$`

Poisson kernel cartoon

]

---

layout: false
.left-column[
## Data structures
### - MWTree
### - MWNode
### - MWOperator
]
.right-column[
#### Poisson operator
- Poisson kernel separated in terms of Gaussians

  `$$
    P(\boldsymbol{x},\boldsymbol{y}) \approx
    \tilde{P}(\boldsymbol{x},\boldsymbol{y}) =
    \sum_\kappa^M \alpha_{\kappa} \prod_{p=1}^d e^{-\beta_{\kappa}(x_p-y_p)^2}
   $$`

- Solves numerical problems
  * Separates coordinates
  * Remove singularity
  * Separates length scales
]

---

layout: false
.left-column[
## Data structures
### - MWTree
### - MWNode
### - MWOperator
]
.right-column[
#### Convolution operators
- Operator reduced to 1D convolutions with Gaussians

  `$$ 
    g(x) = \hat{T}f(x) = \int \alpha e^{-\beta (x-y)^2} f(y) dy
   $$`

- MW representation by scaling projection of the 2D kernel

  `$$ 
    T_{lm}^N = \int \int K(x,y) \phi_l^N(x)\phi_m^N(y) dxdy
   $$`

- `\(l\)` and `\(m\)` are translation indices of nodes
  in the output and input functions, respectively

- MW transform to obtain wavelet terms

  `$$
    T^{N} = T^{N-1} + C^{N-1} + B^{N-1} + A^{N-1}
   $$`

]

---

layout: false
.left-column[
## Data structures
### - MWTree
### - MWNode
### - MWOperator
]
.right-column[
#### Convolution operators
  `$$
    T^{N} = T^{N-1} + C^{N-1} + B^{N-1} + A^{N-1}
   $$`

<img src="images/vanishing_moments.jpg" style="float: center">


]


---

layout: false
.left-column[
## Data structures
### - MWTree
### - MWNode
### - MWOperator
]
.right-column[
#### Convolution operators
  `$$
    T^{N+1}
   $$`
<img src="images/matrix/matrix_1.jpg" style="float: center;">

]

---

layout: false
.left-column[
## Data structures
### - MWTree
### - MWNode
### - MWOperator
]
.right-column[
#### Convolution operators
  `$$
    T^{N+1} = T^{N} + C^{N} + B^{N} + A^{N}
   $$`
<img src="images/matrix/matrix_2.jpg" style="float: center;">

]

---

layout: false
.left-column[
## Data structures
### - MWTree
### - MWNode
### - MWOperator
]
.right-column[
#### Convolution operators
  `$$
    T^{N+1} = \Big(T^{N}\Big) + C^{N} + B^{N} + A^{N}
   $$`
<img src="images/matrix/matrix_3.jpg" style="float: center;">

]

---

layout: false
.left-column[
## Data structures
### - MWTree
### - MWNode
### - MWOperator
]
.right-column[
#### Convolution operators
  `$$
    T^{N+1} = \Big(T^{N-1} + C^{N-1} + B^{N-1} + A^{N-1}\Big) + C^{N} + B^{N} + A^{N}
   $$`
<img src="images/matrix/matrix_4.jpg" style="float: center;">

]

---

layout: false
.left-column[
## Data structures
### - MWTree
### - MWNode
### - MWOperator
]
.right-column[
#### Convolution operators
  `$$
    T^{N+1} = T^{N-2} + \sum_{n=N-2}^N \Big(C^{n} + B^{n} + A^{n}\Big)
   $$`
<img src="images/matrix/matrix_5.jpg" style="float: center;">

]

---

layout: false
.left-column[
## Data structures
### - MWTree
### - MWNode
### - MWOperator
]
.right-column[
#### Convolution operators
  `$$
    T^{N+1} = T^{N-3} + \sum_{n=N-3}^N \Big(C^{n} + B^{n} + A^{n}\Big)
   $$`
<img src="images/matrix/matrix_6.jpg" style="float: center;">

]

---

layout: false
.left-column[
## Data structures
### - MWTree
### - MWNode
### - MWOperator
]
.right-column[
#### Convolution operators

- MW operators are 2D trees

- Operator decompositions
  * Gaussian expansion
  * Separated dimension
  * Separated length scales
  * MW decomposition
  `$$
    T^{N} = T^0 + \sum_{n=0}^{N-1} \Big(C^n + B^n + A^n\big)
   $$`

- Linear scaling
  * Vanishing moments
  * Thresholding
  * Bandwidths
]

---
template: inverse
# Algorithms
---

layout: false
.left-column[
## Algorithms
### - Adaptivity
### - Thresholding
]
.right-column[
- Tree building algorithm
- Function thresholding
- MW transforms
]

---

layout: false
.left-column[
## Algorithms
### - Projection
### - Addition
### - Multiplication
### - Operator application
]
.right-column[
- Interpolating property
- cvTransform
- mwTransform
- NS form
- Bandwidths
- Pointer array
- Operator thresholding
- GenNodes
]

---
template: inverse
# Parallelization
---

layout: false
.left-column[
## Parallelization
]
.right-column[
- Tree building algorithm
]

---

name: last-page
template: inverse

Slideshow created using [remark] and served using [cicero]

[remark]: https://github.com/gnab/remark
[cicero]: https://github.com/bast/cicero
